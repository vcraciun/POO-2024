utilizare extern
 - pe variabile
 - pe include atunci cand importam cod C in C++ si invers
cast / auto-cast
 - cum functioneaza castul pe tipuri de date non-pointer
 - cum functioneaza castul pe tipuri de date pointer
 - cum functioneaza auto-cast-ul in C (putem scrie: char* x = malloc(100); in fisier cu extensia .c)
 - cum functioneaza auto-cast-ul in c++
exceptii (SEH, sjlj, try-catch)
 - pentru C - un exemplu SEH si un exemplu SJLJ
 - pentru C++ - un exemplu try-throw-catch
static (functii, variabile)
 - static pentru variabile (pot sa aflu valoarea unei variabile static declarata in f1(), din f2() daca stiu unde sa caut)
 - static pentru functii (unicitate la nivel de modul)
lungime tipuri de date si structuri
 - tipuri standard
 - structuri
structuri cu variabile si functii
 - dimensiunile unor structuri care mixeaza declaratii de variabile si functii
 - demonstratie cu debuggerul ca functiile nu ocupa loc in structura ci structura este doar o metoda de acces la cod
 - aliniere default si fortare aliniere structuri cu #pragma pack
pointer, pointer dublu, referinta, pointer la functie
 - utilizare pointeri simpli
 - utilizare pointeri dubli
 - utilizare referinte
 - utilizare pointeri la functie
stiva, heap, cod
 - ce este stiva, heap-ul si zona de cod si cum sunt utilizate la executie?
 - consecinte alocare statica excesiva
 - consecinte return pointer de pe stiva (care se recicleaza dupa return)
 - alocare/dealocare dinamica, utilizare zona de memorie alocata
